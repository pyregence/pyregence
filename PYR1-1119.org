Match drop submit results in a SQL error:

#+begin_quote
SQL Call: SELECT * FROM initialize_match_job(nil)
Error: ERROR: null value in column "user_rid" of relation "match_jobs" violates not-null constraint
Detail: Failing row contains (190, null, 2025-06-03 19:20:00.264531, 2025-06-03 19:20:00.264531, 2, null, , f, f, null, null, null, null, null, null, null).
Where: SQL function "initialize_match_job" statement 1
#+end_quote

However it seems Oliver believes even when this is fixed their will still be an issue because of some microservice, something to do with runway, elmfire, etc...
What follows is potentially related error message from sierra GeoServer:

#+begin_quote
Loading quota store failed, the disk quota subsystem is disabled, please re-configure: Could not open JDBC Connection for transaction; nested exception is org.apache.commons.dbcp.SQLNestedException: Cannot create PoolableConnectionFactory (General error: java.lang.RuntimeException: double allocation in file /opt/geoserver/data/gwc/diskquota_page_store_h2/diskquota.index.db page 6264 blocks 400896-400959 [50000-119])
#+end_quote

We have a [[https://github.com/pyregence/pyregence/pull/956][PR to initiate match drop]], the PR says:

Fixes a bug introduced in #934 where the `match-drop/initiate-md!` function didn't correctly pass along the `user-id` parameter, which lead to errors of the following type, which prevent Match Drops from initiating:

#+begin_quote
"ERROR: null value in column \"user_rid\" of relation \"match_jobs\" violates not-null constraint\n  Detail: Failing row contains (203, null, 2025-07-31 14:18:48.712312, 2025-07-31 14:18:48.712312, 2, null, , f, f, null, null, null, null, null, null, null).\n  Where: SQL function \"initialize_match_job\" statement 1"
#+end_quote

Here is the diff:

#+begin_src diff
modified   src/clj/pyregence/match_drop.clj
@@ -268,6 +268,7 @@

 (defn- create-match-job!
   [{:keys [display-name user-id ignition-time lat lon wx-type] :as params}]
+  {:pre [(integer? user-id)]}
   (let [runway-job-id        (str (UUID/randomUUID))
         match-job-id         (initialize-match-job! user-id)
         west-buffer          12
@@ -390,11 +391,11 @@
          (pos? (count-running-user-match-jobs user-id))
          {:error "Match drop is already running. Please wait until it has completed."}

-         (< (get-md-config :max-queue-size) (count-all-running-match-drops))
+         (<= (get-md-config :max-queue-size) (count-all-running-match-drops))
          {:error "The queue is currently full. Please try again later."}

          :else
-         (create-match-job! match-drop-job-params))))))
+         (create-match-job! (assoc match-drop-job-params :user-id user-id)))))))

 (defn get-match-drops
   "Returns the user's match drops."
@@ -588,8 +589,8 @@
     2       (do
               (log-str (str "Geoserver workspace is " geoserver-workspace))
               ;; NOTE: set-capabilities! isn't handled by the GeoSync action hook since GeoSync is running in CLI mode in the GeoSync microservice (action hooks only work in server mode).
-              (set-capabilities! {"geoserver-key"  "match-drop"
-                                  "workspace-name" geoserver-workspace})
+              (set-capabilities! nil {"geoserver-key"  "match-drop"
+                                      "workspace-name" geoserver-workspace})
               (log-str (str "Match Drop layers successfully added to Pyrecast! "
                             "Match Drop job #" match-job-id " is complete."))
               (update-match-job! {:match-job-id match-job-id
@@ -603,8 +604,8 @@
             ;; TODO in the future we should make sure that the front-end is updated as soon as the workspace is removed.
             ;; we will need to do something similar to the refresh-fire-names! fn in match_drop_tool.cljs, but only call
             ;; it once this section of the code is hit.
-            (remove-workspace! {"geoserver-key"  "match-drop"
-                                "workspace-name" geoserver-workspace}))
+            (remove-workspace! nil {"geoserver-key"  "match-drop"
+                                    "workspace-name" geoserver-workspace}))

     :else (update-match-drop-on-error! match-job-id
                                        {:job-id  job-id
#+end_src

but none of the none of the microservices are live on the [[https://sierra.pyregence.org/geoserver/web/][Sierra GeoServer]] which as this error:

#+begin_quote
Loading quota store failed, the disk quota subsystem is disabled, please re-configure: Could not open JDBC Connection for transaction; nested exception is org.apache.commons.dbcp.SQLNestedException: Cannot create PoolableConnectionFactory (General error: java.lang.RuntimeException: double allocation in file /opt/geoserver/data/gwc/diskquota_page_store_h2/diskquota.index.db page 6264 blocks 400896-400959 [50000-119])
#+end_quote

Oliver's TODOS that i haven't vetted:
- Make sure the gridfire servers on the 4 compute nodes are running.
- Make sure that the version of ELMFIRE that we’re using in our microservices is installed on the 4 compute nodes.
- Make sure that the request the PyreCast Match Drop client is making matches the latest syntax/accepted parameters for Chris’s WorldGen server.
- Make sure our Sierra GeoServer is still working as expected.
- Coordinate with Chris to push the priority of a few Match Drop runs so that we don’t have to wait multiple hours for each one to finish (due to being in the queue).

Gary says the namespaces to look at are near_term_forecast.cljs, match_drop.clj, match_functions.sql and ultimately submits jobs via the Runway protocol to our SLURM cluster's microservices. You could check with @aliceliquori and/or @daniel-silva for support with those if you get this far and it looks like the job is failing after being submitted via Runway.
